/***********************************************************************************************************
Generated by the KT-Adaptive-Generator!
The tool version : V2.2.1-e71a77.dirty
Copyright(C) 2021 Wuhan KOTEI Informatics Co.,Ltd. All rights reserved
***********************************************************************************************************/

#ifndef _V1_INTERCOMMUNICATION_COMMON_H_
#define _V1_INTERCOMMUNICATION_COMMON_H_

#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#include <functional>
#include <iostream>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <typeinfo>

#include "APF/SerializableArguments.h"

#include "someipMessage/someip_data_bitfield.h"
#include "someipMessage/someip_data_common.h"
#include "someipMessage/someip_data_string.h"
#include "someipMessage/someip_data_structure.h"
#include "someipMessage/someip_data_union.h"

#ifndef CONFIG_FORCE_POLLING
#define CONFIG_FORCE_POLLING 0
#endif

#ifndef CONFIG_SOALIB_LOG
#define CONFIG_SOALIB_LOG

enum class SOALibLogLevel : uint8_t {
    L_CLOSE = 0x00,
    L_WARNING = 0x03,
    L_INFO = 0x04,
    L_DEBUG = 0x05
};

#ifndef CONFIG_SOALIB_LOG_LEVEL
#define CONFIG_SOALIB_LOG_LEVEL SOALibLogLevel::L_INFO
#endif

#if defined(__ANDROID__)
#include "android/log.h"
#define soaSlogD(...)                                                          \
    { __android_log_print(ANDROID_LOG_DEBUG, "SOALIB", __VA_ARGS__); }
#define soaSlogI(...)                                                          \
    { __android_log_print(ANDROID_LOG_INFO, "SOALIB", __VA_ARGS__); }
#define soaSlogW(...)                                                          \
    { __android_log_print(ANDROID_LOG_WARN, "SOALIB", __VA_ARGS__); }
#elif defined(__QNX__)
#include <sys/slog.h>
#include <sys/slogcodes.h>
#define _SLOGC_SYNCORE (_SLOGC_3RDPARTY_OEM00001_START + 1)

#define soaSlogD(frm, args...)                                                 \
    { slogf(_SLOGC_SYNCORE, _SLOG_INFO, "D " frm, ##args); }
#define soaSlogI(frm, args...)                                                 \
    { slogf(_SLOGC_SYNCORE, _SLOG_INFO, "I " frm, ##args); }
#define soaSlogW(frm, args...)                                                 \
    { slogf(_SLOGC_SYNCORE, _SLOG_WARNING, "W " frm, ##args); }
#elif defined(__linux__)
#define soaSlogD(frm, args...)                                                 \
    { printf("D " frm " \n", ##args); }
#define soaSlogI(frm, args...)                                                 \
    { printf("I " frm " \n", ##args); }
#define soaSlogW(frm, args...)                                                 \
    { printf("W " frm " \n", ##args); }
#endif
#endif // CONFIG_SOALIB_LOG

#define INTERREQUESTRR_METHOD_ID 0x0001
#define INTERREQUEST_METHOD_ID 0x1001
#define INTERFIELD_GETTER_ID 0x5001
#define INTERFIELD_SETTER_ID 0x6001
#define INTERFIELD_UPDATE_ID 0x9001
#define INTERFIELDARR_UPDATE_ID 0x9002
#define INTEREVENT_EVENT_ID 0x8001
#define INTEREVENTARR_EVENT_ID 0x8002
#define EVENTGROUP_INTERCOMMUNICATION 0x0001

namespace v1 {
namespace ara_api {
namespace InterCommunication {
//[SWS_CM_01010]
class InterCommunicationIdentifier {
  public:
    static constexpr ara::com::ServiceIdentifierType ServiceIdentifier =
        ara::com::ServiceIdentifierType(
            std::array<char, SERVICE_IDENTIFIER_MAX_LENGTH>{
                "ara_api.InterCommunication"});
    static constexpr ara::com::ServiceVersionType ServiceVersion =
        ara::com::ServiceVersionType(
            std::array<char, SERVICE_VERSION_MAX_LENGTH>{
                "V2.2.1-e71a77.dirty-Matrix_V2.0-20241030.release"});
    static std::uint8_t serviceContractVersionMajor;
    static std::uint32_t serviceContractVersionMinor;
    static uint32_t CreateProxyID();
};
class InterCommunicationInit {
  public:
    InterCommunicationInit();
};

typedef apf::someip::StringWithLen<ara::core::String, uint32_t, 1024>
    String_DataMsg;
typedef uint8_t Uint8_Rawdata;

typedef apf::someip::DynLenArray<Uint8_Rawdata, uint32_t> Array_InterComm;
struct Struct_InterFieldData : public apf::someip::Struct<uint32_t> {
    Struct_InterFieldData() {}

    void setUint8_DataID(const uint8_t &_Uint8_DataID);
    uint8_t getUint8_DataID() const;
    void setString_DataMsg(const ara::core::String &_String_DataMsg);
    ara::core::String getString_DataMsg() const {
        return m_String_DataMsg.getStringValue();
    }
    virtual uint32_t getSize() override;

    friend apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                                         Struct_InterFieldData &_data);

    friend apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                                       Struct_InterFieldData &_data);

  private:
    uint8_t m_Uint8_DataID;
    String_DataMsg m_String_DataMsg;
};
struct Struct_InterField : public apf::someip::Struct<uint32_t> {
    Struct_InterField() {}

    void setUint8_InterFieldID(const uint8_t &_Uint8_InterFieldID);
    uint8_t getUint8_InterFieldID() const;
    void setStruct_InterFieldData(
        const Struct_InterFieldData &_Struct_InterFieldData);
    Struct_InterFieldData getStruct_InterFieldData() const;
    virtual uint32_t getSize() override;

    friend apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                                         Struct_InterField &_data);

    friend apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                                       Struct_InterField &_data);

  private:
    uint8_t m_Uint8_InterFieldID;
    Struct_InterFieldData m_Struct_InterFieldData;
};
struct Struct_InterFieldStArr : public apf::someip::Struct<uint32_t> {
    Struct_InterFieldStArr() {}

    void setUint8_DataID(const uint8_t &_Uint8_DataID);
    uint8_t getUint8_DataID() const;
    void setArray_InterComm(const Array_InterComm &_Array_InterComm);
    Array_InterComm getArray_InterComm() const;
    void setString_DataMsg(const ara::core::String &_String_DataMsg);
    ara::core::String getString_DataMsg() const {
        return m_String_DataMsg.getStringValue();
    }
    virtual uint32_t getSize() override;

    friend apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                                         Struct_InterFieldStArr &_data);

    friend apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                                       Struct_InterFieldStArr &_data);

  private:
    uint8_t m_Uint8_DataID;
    Array_InterComm m_Array_InterComm;
    String_DataMsg m_String_DataMsg;
};
typedef apf::someip::StringWithLen<ara::core::String, uint32_t, 1024>
    String_InterComm;

enum class InterCommunicationErrc : ara::core::ErrorDomain::CodeType {
    error_code1 = 1,
};

class InterCommunicationException : public ara::core::Exception {
  public:
    // \brief Construct a new ConnMgrErrcException from an ErrorCode.
    explicit InterCommunicationException(ara::core::ErrorCode err) noexcept;

    char const *what() const noexcept override;
    ara::core::ErrorCode const &Error() const noexcept;
};
class InterCommunicationErrorDomain final : public ara::core::ErrorDomain {
  public:
    // Alias for the error code value enumeration.
    using Errc = InterCommunicationErrc;

    // Alias for the exception base class.
    using Exception = InterCommunicationException;

    // Default constructor
    constexpr InterCommunicationErrorDomain() noexcept
        : ara::core::ErrorDomain(1000001) {}

    // \brief Return the "short name" ApApplicationErrorDomain.SN of this error
    // domain.
    char const *Name() const noexcept override;

    // Translate an error code value into a text message
    char const *
    Message(ErrorDomain::CodeType errorCode) const noexcept override;

    // Throw the exception type corresponding to the given ErrorCode.
    void ThrowAsException(ara::core::ErrorCode const &errorCode) const
        noexcept(false) override;
};

constexpr ara::core::ErrorDomain const &
GetInterCommunicationErrcDomain() noexcept;
ara::core::ErrorCode
MakeErrorCode(InterCommunicationErrc code,
              ara::core::ErrorDomain::SupportDataType data = 0,
              char const *message = nullptr) noexcept;

static InterCommunicationErrorDomain s_InterCommunication_error_domain;
class InterCommunicationTmpCalss {
    friend constexpr ara::core::ErrorDomain const &
    GetInterCommunicationErrcDomain() noexcept;

    friend ara::core::ErrorCode
    MakeErrorCode(InterCommunicationErrc code,
                  ara::core::ErrorDomain::SupportDataType data,
                  char const *message) noexcept;
};
}; // namespace InterCommunication
}; // namespace ara_api
}; // namespace v1
namespace ara {
namespace core {
template <>
struct is_error_code_enum<
    v1::ara_api::InterCommunication::InterCommunicationErrc>
    : std::true_type { // for ErrorCode constructor overload resolution
};
}; // namespace core
}; // namespace ara

#endif