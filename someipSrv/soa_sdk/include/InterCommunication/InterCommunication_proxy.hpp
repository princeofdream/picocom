/***********************************************************************************************************
Generated by the KT-Adaptive-Generator!
The tool version : V2.2.1-e71a77.dirty
Copyright(C) 2021 Wuhan KOTEI Informatics Co.,Ltd. All rights reserved
***********************************************************************************************************/

#ifndef _V1_INTERCOMMUNICATION_PROXY_H_
#define _V1_INTERCOMMUNICATION_PROXY_H_

#include "InterCommunication_common.hpp"
#include "ara/com/types.h"
#include "ara_message.hpp"
#include "ara_runtime.hpp"
#include <deque>
#include <list>
#include <map>
#include <thread>

using std::string;

namespace v1 {
namespace ara_api {
namespace InterCommunication {
namespace proxy {
namespace methods {

class InterRequestRR {
  public:
    InterRequestRR(ara::com::InstanceIdentifier _identifier);

    ara::core::Future<Array_InterComm>
    operator()(Array_InterComm &Array_InterReq);
    ~InterRequestRR();
    void RecvResponseHandle(ara::Message _msg);

  private:
    std::map<ara::com::internal::SessionId, ara::core::Promise<Array_InterComm>>
        m_wait_return_map;
    ara::com::InstanceIdentifier m_identifier;
};
class InterRequest {
  public:
    InterRequest(ara::com::InstanceIdentifier _identifier);

    void operator()(Array_InterComm &Array_InterReq);

  private:
    ara::com::InstanceIdentifier m_identifier;
};
} // namespace methods

namespace events {
class InterEvent {
  public:
    InterEvent(ara::com::InstanceIdentifier _identifier);
    using SampleType = String_InterComm;

    void RecvEventHandle(ara::Message _msg);
    /*
     * [SWS_CM_00141] 20.11
     * ComErrc::kMaxSampleCountNotRealizable
     */
    ara::core::Result<void> Subscribe(size_t maxSampleCount);
    //[SWS_CM_00151]
    void Unsubscribe();
    //[SWS_CM_00316]
    ara::com::SubscriptionState GetSubscriptionState() const;
    /*
     * [SWS_CM_00333] 20.11
     * kServiceNotAvailable
     */
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler);
    /*
     * [SWS_CM_11354] 20.11
     */
    template <typename ExecutorT>
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler, ExecutorT &&executor);
    //[SWS_CM_00334]
    void UnsetSubscriptionStateChangeHandler();
    //[SWS_CM_00181]
    ara::core::Result<void>
    SetReceiveHandler(ara::com::EventReceiveHandler handler);
    //[SWS_CM_00183]
    void UnsetReceiveHandler();
    //[SWS_CM_00701]
    //[SWS_CM_00702] F:void(ara::com::SamplePtr<SampleType const>)
    // kMaxSamplesReached
    template <typename F>
    ara::core::Result<size_t> GetNewSamples(
        F &&f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max()) {
        std::lock_guard<std::mutex> its_lock(m_getting_sample_mutex);
        size_t num = 0;
        while (true) {
            ara::Message event_;
            {
                std::lock_guard<std::mutex> data_lock(
                    m_lastNActiveSamples_mutex);
                if (m_lastNActiveSamples.empty()) {
                    break;
                }
                event_ = m_lastNActiveSamples.front();
                m_lastNActiveSamples.pop_front();
            }
            num++;

            ara::com::SamplePtr<SampleType> samplePtr =
                ara::com::make_sample<SampleType>();
            uint16_t check_result = event_.getCheckResult();
            switch (check_result) {
            case 0: {
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Ok);
                apf::Deserializer _in(event_.getBodyData(),
                                      event_.getBodyLength());
                String_InterComm value;
                if (apf::someip::SerializableArguments<
                        String_InterComm>::Deserializer(_in, value)) {
                    *samplePtr = value;
                } else {
                    samplePtr.SetProfileCheckStatus(
                        ara::com::e2e::ProfileCheckStatus::Error);
                }
                break;
            }
            case 1:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::WrongSequence);
                break;
            case 2:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Error);
                break;
            default:
                break;
            }

            f(std::move(samplePtr));

            if (num == maxNumberOfSamples) {
                break;
            }
        }
        return ara::core::Result<size_t>::FromValue(num);
    }
    // 20.11
    // template<typename F,typename ExecutorT>
    // ara::core::Result<size_t> GetNewSamples(
    //     F&& f, size_t maxNumberOfSamples =
    //     std::numeric_limits<size_t>::max(),ExecutorT&& executor);
    //[SWS_CM_90424] Provide E2E Result
    const ara::com::e2e::Result GetResult() const;
    //[SWS_CM_00705]
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept;

  private:
    uint32_t m_max_sample_count = 0;
    std::mutex m_getting_sample_mutex;
    bool m_is_subscribed = false;
    std::mutex m_lastNActiveSamples_mutex;
    ara::com::InstanceIdentifier m_identifier;
    ara::call_back_id m_call_back_id;
    std::thread m_call_back_thread;
    bool m_running;

  public:
    ara::com::EventReceiveHandler m_receive_handle = nullptr;
    std::deque<ara::Message> m_lastNActiveSamples;
};

class InterEventArr {
  public:
    InterEventArr(ara::com::InstanceIdentifier _identifier);
    using SampleType = Array_InterComm;

    void RecvEventHandle(ara::Message _msg);
    /*
     * [SWS_CM_00141] 20.11
     * ComErrc::kMaxSampleCountNotRealizable
     */
    ara::core::Result<void> Subscribe(size_t maxSampleCount);
    //[SWS_CM_00151]
    void Unsubscribe();
    //[SWS_CM_00316]
    ara::com::SubscriptionState GetSubscriptionState() const;
    /*
     * [SWS_CM_00333] 20.11
     * kServiceNotAvailable
     */
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler);
    /*
     * [SWS_CM_11354] 20.11
     */
    template <typename ExecutorT>
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler, ExecutorT &&executor);
    //[SWS_CM_00334]
    void UnsetSubscriptionStateChangeHandler();
    //[SWS_CM_00181]
    ara::core::Result<void>
    SetReceiveHandler(ara::com::EventReceiveHandler handler);
    //[SWS_CM_00183]
    void UnsetReceiveHandler();
    //[SWS_CM_00701]
    //[SWS_CM_00702] F:void(ara::com::SamplePtr<SampleType const>)
    // kMaxSamplesReached
    template <typename F>
    ara::core::Result<size_t> GetNewSamples(
        F &&f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max()) {
        std::lock_guard<std::mutex> its_lock(m_getting_sample_mutex);
        size_t num = 0;
        while (true) {
            ara::Message event_;
            {
                std::lock_guard<std::mutex> data_lock(
                    m_lastNActiveSamples_mutex);
                if (m_lastNActiveSamples.empty()) {
                    break;
                }
                event_ = m_lastNActiveSamples.front();
                m_lastNActiveSamples.pop_front();
            }
            num++;

            ara::com::SamplePtr<SampleType> samplePtr =
                ara::com::make_sample<SampleType>();
            uint16_t check_result = event_.getCheckResult();
            switch (check_result) {
            case 0: {
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Ok);
                apf::Deserializer _in(event_.getBodyData(),
                                      event_.getBodyLength());
                Array_InterComm value;
                if (apf::someip::SerializableArguments<
                        Array_InterComm>::Deserializer(_in, value)) {
                    *samplePtr = value;
                } else {
                    samplePtr.SetProfileCheckStatus(
                        ara::com::e2e::ProfileCheckStatus::Error);
                }
                break;
            }
            case 1:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::WrongSequence);
                break;
            case 2:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Error);
                break;
            default:
                break;
            }

            f(std::move(samplePtr));

            if (num == maxNumberOfSamples) {
                break;
            }
        }
        return ara::core::Result<size_t>::FromValue(num);
    }
    // 20.11
    // template<typename F,typename ExecutorT>
    // ara::core::Result<size_t> GetNewSamples(
    //     F&& f, size_t maxNumberOfSamples =
    //     std::numeric_limits<size_t>::max(),ExecutorT&& executor);
    //[SWS_CM_90424] Provide E2E Result
    const ara::com::e2e::Result GetResult() const;
    //[SWS_CM_00705]
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept;

  private:
    uint32_t m_max_sample_count = 0;
    std::mutex m_getting_sample_mutex;
    bool m_is_subscribed = false;
    std::mutex m_lastNActiveSamples_mutex;
    ara::com::InstanceIdentifier m_identifier;
    ara::call_back_id m_call_back_id;
    std::thread m_call_back_thread;
    bool m_running;

  public:
    ara::com::EventReceiveHandler m_receive_handle = nullptr;
    std::deque<ara::Message> m_lastNActiveSamples;
};

} // namespace events

namespace fields {

class InterField {
  public:
    InterField(ara::com::InstanceIdentifier _identifier);
    using FieldType = Struct_InterField;

    ~InterField();
    void RecvEventHandle(ara::Message _msg);

    ara::core::Result<void> Subscribe(size_t maxSampleCount);
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept;
    ara::com::SubscriptionState GetSubscriptionState() const;
    void Unsubscribe();
    ara::core::Result<void>
    SetReceiveHandler(ara::com::EventReceiveHandler handler);
    void UnsetReceiveHandler();
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler);
    void UnsetSubscriptionStateChangeHandler();
    template <typename F>
    ara::core::Result<size_t> GetNewSamples(
        F &&f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max()) {
        std::lock_guard<std::mutex> its_lock(m_getting_sample_mutex);
        size_t num = 0;
        while (true) {
            ara::Message event_;
            {
                std::lock_guard<std::mutex> data_lock(
                    m_lastNActiveSamples_mutex);
                if (m_lastNActiveSamples.empty()) {
                    break;
                }
                event_ = m_lastNActiveSamples.front();
                m_lastNActiveSamples.pop_front();
            }
            num++;

            ara::com::SamplePtr<FieldType> samplePtr =
                ara::com::make_sample<FieldType>();
            uint16_t check_result = event_.getCheckResult();
            switch (check_result) {
            case 0: {
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Ok);
                apf::Deserializer _in(event_.getBodyData(),
                                      event_.getBodyLength());

                Struct_InterField value;
                if (apf::someip::SerializableArguments<
                        Struct_InterField>::Deserializer(_in, value)) {
                    *samplePtr = value;
                } else {
                    samplePtr.SetProfileCheckStatus(
                        ara::com::e2e::ProfileCheckStatus::Error);
                }
                break;
            }
            case 1:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::WrongSequence);
                break;
            case 2:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Error);
                break;
            case 3:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::NotAvailable);
                break;
            default:
                break;
            }

            f(std::move(samplePtr));

            if (num == maxNumberOfSamples) {
                break;
            }
        }
        return ara::core::Result<size_t>::FromValue(num);
    }

    void RecvResponseHandle(ara::Message _msg);

    ara::core::Future<FieldType> Get();

    ara::core::Future<FieldType> Set(FieldType &value);

  private:
    ara::com::InstanceIdentifier m_identifier;
    uint32_t m_max_sample_count = 0;
    std::mutex m_getting_sample_mutex;
    bool m_is_subscribed = false;
    std::mutex m_lastNActiveSamples_mutex;
    ara::call_back_id m_call_back_id;
    std::thread m_call_back_thread;
    bool m_running;
    std::map<ara::com::internal::SessionId, ara::core::Promise<FieldType>>
        m_wait_return_map;

  public:
    ara::com::EventReceiveHandler m_receive_handle = nullptr;
    std::deque<ara::Message> m_lastNActiveSamples;
};
class InterFieldArr {
  public:
    InterFieldArr(ara::com::InstanceIdentifier _identifier);
    using FieldType = Struct_InterFieldStArr;

    ~InterFieldArr();
    void RecvEventHandle(ara::Message _msg);

    ara::core::Result<void> Subscribe(size_t maxSampleCount);
    ara::core::Result<size_t> GetFreeSampleCount() const noexcept;
    ara::com::SubscriptionState GetSubscriptionState() const;
    void Unsubscribe();
    ara::core::Result<void>
    SetReceiveHandler(ara::com::EventReceiveHandler handler);
    void UnsetReceiveHandler();
    ara::core::Result<void> SetSubscriptionStateChangeHandler(
        ara::com::SubscriptionStateChangeHandler handler);
    void UnsetSubscriptionStateChangeHandler();
    template <typename F>
    ara::core::Result<size_t> GetNewSamples(
        F &&f, size_t maxNumberOfSamples = std::numeric_limits<size_t>::max()) {
        std::lock_guard<std::mutex> its_lock(m_getting_sample_mutex);
        size_t num = 0;
        while (true) {
            ara::Message event_;
            {
                std::lock_guard<std::mutex> data_lock(
                    m_lastNActiveSamples_mutex);
                if (m_lastNActiveSamples.empty()) {
                    break;
                }
                event_ = m_lastNActiveSamples.front();
                m_lastNActiveSamples.pop_front();
            }
            num++;

            ara::com::SamplePtr<FieldType> samplePtr =
                ara::com::make_sample<FieldType>();
            uint16_t check_result = event_.getCheckResult();
            switch (check_result) {
            case 0: {
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Ok);
                apf::Deserializer _in(event_.getBodyData(),
                                      event_.getBodyLength());

                Struct_InterFieldStArr value;
                if (apf::someip::SerializableArguments<
                        Struct_InterFieldStArr>::Deserializer(_in, value)) {
                    *samplePtr = value;
                } else {
                    samplePtr.SetProfileCheckStatus(
                        ara::com::e2e::ProfileCheckStatus::Error);
                }
                break;
            }
            case 1:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::WrongSequence);
                break;
            case 2:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::Error);
                break;
            case 3:
                samplePtr.SetProfileCheckStatus(
                    ara::com::e2e::ProfileCheckStatus::NotAvailable);
                break;
            default:
                break;
            }

            f(std::move(samplePtr));

            if (num == maxNumberOfSamples) {
                break;
            }
        }
        return ara::core::Result<size_t>::FromValue(num);
    }

  private:
    ara::com::InstanceIdentifier m_identifier;
    uint32_t m_max_sample_count = 0;
    std::mutex m_getting_sample_mutex;
    bool m_is_subscribed = false;
    std::mutex m_lastNActiveSamples_mutex;
    ara::call_back_id m_call_back_id;
    std::thread m_call_back_thread;
    bool m_running;

  public:
    ara::com::EventReceiveHandler m_receive_handle = nullptr;
    std::deque<ara::Message> m_lastNActiveSamples;
};
} // namespace fields

class InterCommunicationProxy {
  public:
    //[SWS_CM_00312]
    class HandleType {
      public:
        HandleType(std::string instance_name,
                   ara::com::internal::ServiceId _service_id,
                   ara::com::internal::InstanceId _instance_id);
        bool operator==(const HandleType &other) const;
        bool operator<(const HandleType &other) const;
        const ara::com::InstanceIdentifier &GetInstanceId() const;
        //[SWS_CM_00317]
        HandleType(const HandleType &other);
        HandleType &operator=(const HandleType &other);
        //[SWS_CM_00318]
        HandleType(HandleType &&other);
        HandleType &operator=(HandleType &&other);
        ara::com::internal::ServiceId get_service_id();
        ara::com::internal::InstanceId get_instance_id();

      private:
        ara::com::internal::ServiceId service_id;
        ara::com::internal::InstanceId instance_id;
        ara::com::InstanceIdentifier instance_identifier;
    };
    /*
     * [SWS_CM_00122] 20.11
     * kNetworkBindingFailure: Local failure has been detected by the network
     * binding. kGrantEnforcementError: Request was refused by Grant enforcement
     * layer. kPeerIsUnreachable: Transport Layer Security handshake failed.
     */
    static ara::core::Result<ara::com::ServiceHandleContainer<HandleType>>
    FindService(void);
    static ara::core::Result<ara::com::ServiceHandleContainer<HandleType>>
    FindService(ara::com::InstanceIdentifier instanceId);
    //[SWS_CM_00622] 20.11
    static ara::core::Result<ara::com::ServiceHandleContainer<HandleType>>
    FindService(ara::core::InstanceSpecifier instanceSpec);

    /*
     * [SWS_CM_00123] 20.11
     * kNetworkBindingFailure: Local failure has been detected by the network
     * binding. kGrantEnforcementError: Request was refused by Grant enforcement
     * layer. kPeerIsUnreachable: Transport Layer Security handshake failed.
     */
    static ara::core::Result<ara::com::ServiceHandleContainer<HandleType>>
    StartFindService(ara::ServiceStatusCallback _cb);
    //[SWS_CM_00125]
    static void StopFindService(ara::com::FindServiceHandle handle);
    //[SWS_CM_00131]
    explicit InterCommunicationProxy(const HandleType &handle);
    //[SWS_CM_11326] in 20.11
    static ara::core::Result<InterCommunicationProxy>
    Create(const HandleType &handle) noexcept;
    //[SWS_CM_00136]
    InterCommunicationProxy(const InterCommunicationProxy &) = delete;
    InterCommunicationProxy &
    operator=(const InterCommunicationProxy &) = delete;
    //[SWS_CM_00137]
    InterCommunicationProxy(InterCommunicationProxy &&_Right);
    InterCommunicationProxy &operator=(InterCommunicationProxy &&_Right);

    void Init();
    void Deinit();
    //[SWS_CM_10446]
    ~InterCommunicationProxy();

    // methods
    methods::InterRequestRR InterRequestRR;
    methods::InterRequest InterRequest; // events
    events::InterEvent InterEvent;
    events::InterEventArr InterEventArr; // fields
    fields::InterField InterField;
    fields::InterFieldArr InterFieldArr;
    //[SWS_CM_10383]
    HandleType GetHandle() const;
    void setClientID(const char *jsonFilePath, const char *serviceName);
    void getClientID(const char *&client_id);

  private:
    HandleType m_proxy_handle;
    std::unique_ptr<ara::com::FindServiceHandle> m_find_handle;
    ara::com::FindServiceHandler<HandleType> m_find_handler_func;
    bool _running = false;
#if CONFIG_FORCE_POLLING
    void GetMethodCallResult_Doing();
    std::thread m_get_method_result_thread;
#endif // CONFIG_FORCE_POLLING
    const char *m_clientId;
};
} // namespace proxy
} // namespace InterCommunication
} // namespace ara_api
} // namespace v1
#endif // !_InterCommunication_PROXY_H_