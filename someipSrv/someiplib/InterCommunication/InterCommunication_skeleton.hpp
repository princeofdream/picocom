/***********************************************************************************************************
Generated by the KT-Adaptive-Generator!
The tool version : V2.2.1-e71a77
Copyright(C) 2021 Wuhan KOTEI Informatics Co.,Ltd. All rights reserved
***********************************************************************************************************/

#ifndef _V1_INTERCOMMUNICATION_SKELETON_H_
#define _V1_INTERCOMMUNICATION_SKELETON_H_
#include "InterCommunication_common.hpp"
#include "ara/com/types.h"
#include "ara_runtime.hpp"
#include <map>
#include <thread>
using std::string;

namespace v1 {
namespace ara_api {
namespace InterCommunication {
namespace skeleton {
namespace events {
class InterEvent {
  public:
    InterEvent(ara::com::InstanceIdentifierContainer *_p);
    using SampleType = String_InterComm;

    /*
     * [SWS_CM_00162]20.11
     * ComErrc::kServiceNotOffered: Service not offered.
     * ComErrc::kCommunicationLinkError: Communication link is broken.
     * ComErrc::kNoClients: No clients connected.
     * ComErrc::kCommunicationStackError.
     */
    ara::core::Result<void> Send(SampleType &data);
    /*
     * [SWS_CM_90437]20.11
     * ComErrc::kServiceNotOffered: Service not offered.
     * ComErrc::kCommunicationLinkError: Communication link is broken.
     * ComErrc::kNoClients: No clients connected.
     * ComErrc::kCommunicationStackError.
     */
    ara::core::Result<void> Send(ara::com::SampleAllocateePtr<SampleType> data);
    /*
    * [SWS_CM_90438] 20.11
    * ComErrc::kSampleAllocationFailure: If the allocation of the shared
        memory fails (i.e., failure to retrieve/allocate a shared slot for a
    sample).
    * ComErrc::kIllegalUseOfAllocate:If the allocation is done via custom
    allocator (i.e., not via shared memory allocation).The error shall be
    logged.
    */
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate();

  private:
    ara::com::InstanceIdentifierContainer *_pProvideInstances;
};
class InterEventArr {
  public:
    InterEventArr(ara::com::InstanceIdentifierContainer *_p);
    using SampleType = Array_InterComm;

    /*
     * [SWS_CM_00162]20.11
     * ComErrc::kServiceNotOffered: Service not offered.
     * ComErrc::kCommunicationLinkError: Communication link is broken.
     * ComErrc::kNoClients: No clients connected.
     * ComErrc::kCommunicationStackError.
     */
    ara::core::Result<void> Send(SampleType &data);
    /*
     * [SWS_CM_90437]20.11
     * ComErrc::kServiceNotOffered: Service not offered.
     * ComErrc::kCommunicationLinkError: Communication link is broken.
     * ComErrc::kNoClients: No clients connected.
     * ComErrc::kCommunicationStackError.
     */
    ara::core::Result<void> Send(ara::com::SampleAllocateePtr<SampleType> data);
    /*
    * [SWS_CM_90438] 20.11
    * ComErrc::kSampleAllocationFailure: If the allocation of the shared
        memory fails (i.e., failure to retrieve/allocate a shared slot for a
    sample).
    * ComErrc::kIllegalUseOfAllocate:If the allocation is done via custom
    allocator (i.e., not via shared memory allocation).The error shall be
    logged.
    */
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate();

  private:
    ara::com::InstanceIdentifierContainer *_pProvideInstances;
};
} // namespace events

namespace fields {

class InterField {
  public:
    using FieldType = Struct_InterField;
    InterField(ara::com::InstanceIdentifierContainer *_p);
    bool hasNotifier();
    bool hasGetter();
    bool hasSetter();

    /*
     * kServiceNotOffered: Service not offered.
     * kCommunicationLinkError: Communication link is broken.
     * kNoClients: No clients connected.
     * kCommunicationStackError: Communication Stack Error, e.g. network stack,
     *                           network binding, or communication framework
     * reports an error
     */
    ara::core::Result<void> Update(FieldType &value);

    std::function<ara::core::Future<FieldType>()> m_get_handler;
    std::map<ara::Message, ara::core::Future<FieldType>> m_get_return;
    ara::core::Result<void> RegisterGetHandler(
        std::function<ara::core::Future<FieldType>()> getHandler);
    template <typename ExecutorT>
    ara::core::Result<void>
    RegisterGetHandler(std::function<ara::core::Future<FieldType>()> getHandler,
                       ExecutorT &&executor);

    std::function<ara::core::Future<FieldType>(const FieldType &data)>
        m_set_handler;
    std::map<ara::Message, ara::core::Future<FieldType>> m_set_return;
    ara::core::Result<void> RegisterSetHandler(
        std::function<ara::core::Future<FieldType>(const FieldType &data)>
            setHandler);
    template <typename ExecutorT>
    ara::core::Result<void> RegisterSetHandler(
        std::function<ara::core::Future<FieldType>(const FieldType &value)>
            setHandler,
        ExecutorT &&executor);

  private:
    ara::com::InstanceIdentifierContainer *_pProvideInstances;
    FieldType m_field_value;
};

class InterFieldArr {
  public:
    using FieldType = Struct_InterFieldStArr;
    InterFieldArr(ara::com::InstanceIdentifierContainer *_p);
    bool hasNotifier();
    bool hasGetter();
    bool hasSetter();

    /*
     * kServiceNotOffered: Service not offered.
     * kCommunicationLinkError: Communication link is broken.
     * kNoClients: No clients connected.
     * kCommunicationStackError: Communication Stack Error, e.g. network stack,
     *                           network binding, or communication framework
     * reports an error
     */
    ara::core::Result<void> Update(FieldType &value);

  private:
    ara::com::InstanceIdentifierContainer *_pProvideInstances;
    FieldType m_field_value;
};

} // namespace fields

class InterCommunicationSkeleton {
  public:
    //[SWS_CM_00130]
    InterCommunicationSkeleton(ara::com::InstanceIdentifier instanceID,
                               ara::com::MethodCallProcessingMode mode =
                                   ara::com::MethodCallProcessingMode::kEvent);
    /*
     * [SWS_CM_10435] 20.11
     * In case of a Grant enforcement failure, an error code
     * ComErrc::kGrantEnforcementError shall be returned in the Result.
     */
    static ara::core::Result<InterCommunicationSkeleton>
    Create(const ara::com::InstanceIdentifier &instanceID,
           ara::com::MethodCallProcessingMode mode =
               ara::com::MethodCallProcessingMode::kEvent) noexcept;
    //[SWS_CM_00152]
    InterCommunicationSkeleton(ara::core::InstanceSpecifier instanceSpec,
                               ara::com::MethodCallProcessingMode mode =
                                   ara::com::MethodCallProcessingMode::kEvent);
    /*
     * 20.11
     * In case of a Grant enforcement failure, an error code
     * ComErrc::kGrantEnforcementError shall be returned in the Result.
     */
    static ara::core::Result<InterCommunicationSkeleton>
    Create(const ara::core::InstanceSpecifier &instanceSpec,
           ara::com::MethodCallProcessingMode mode =
               ara::com::MethodCallProcessingMode::kEvent) noexcept;
    //[SWS_CM_00153]
    InterCommunicationSkeleton(
        ara::com::InstanceIdentifierContainer instanceIDs,
        ara::com::MethodCallProcessingMode mode =
            ara::com::MethodCallProcessingMode::kEvent);
    /*
     * 20.11
     * In case of a Grant enforcement failure, an error code
     * ComErrc::kGrantEnforcementError shall be returned in the Result.
     */
    static ara::core::Result<InterCommunicationSkeleton>
    Create(const ara::com::InstanceIdentifierContainer &instanceIDs,
           ara::com::MethodCallProcessingMode mode =
               ara::com::MethodCallProcessingMode::kEvent) noexcept;
    //[SWS_CM_00134]
    InterCommunicationSkeleton(const InterCommunicationSkeleton &) = delete;
    InterCommunicationSkeleton &
    operator=(const InterCommunicationSkeleton &) = delete;
    //[SWS_CM_00135]
    InterCommunicationSkeleton(InterCommunicationSkeleton &&);
    InterCommunicationSkeleton &operator=(InterCommunicationSkeleton &&);
    /*
     * [SWS_CM_00101] 20.11
     * 1.If the offered service contains a Field, and the field value is not
     * valid according to [SWS_CM_00128] when OfferService() is called, the
     * service shall not be offered, and the error code
     * ComErrc::kFieldValueIsNotValid shall be returned in the Result type.
     *
     * 2.If the offered service contains a Field that is defined with
     * hasSetter=true, and no SetHandler has been registered yet, the service
     * shall not be offered, and the error code ComErrc::kSetHandlerNotSet shall
     * be returned in the Result type
     *
     * 3.Re-entrancy - OfferService
     */
    ara::core::Result<void> OfferService();
    //[SWS_CM_00111]
    void StopOfferService();
    //[SWS_CM_00199]
    ara::core::Future<bool> ProcessNextMethodCall();
    // response By kEvent
    ara::core::Future<bool>
    ProcessNextMethodCallBykEvent(ara::Message _message);
    void Init();
    void Deinit();
    ~InterCommunicationSkeleton();
    /*
     * [SWS_CM_11350] 20.11
     */
    template <typename ExecutorT>
    ara::core::Future<bool> ProcessNextMethodCall(ExecutorT &&executor);
    ara::com::MethodCallProcessingMode GetProcessingMode() const;
    // provide methods
    virtual ara::core::Future<Array_InterComm>
    InterRequestRR(Array_InterComm &Array_InterReq) = 0;
    virtual void InterRequest(Array_InterComm &Array_InterReq) = 0;

    // events
    events::InterEvent InterEvent;
    events::InterEventArr InterEventArr;

    // fields
    fields::InterField InterField;
    fields::InterFieldArr InterFieldArr;

  private:
    ara::com::MethodCallProcessingMode m_processing_mode;
    ara::com::InstanceIdentifierContainer m_provid_instances;

    void GetMethodCallResult_Doing();
    bool _running = false;
    std::thread m_get_method_result_thread;
    std::map<ara::Message, ara::core::Future<Array_InterComm>>
        m_InterRequestRR_Return;
};
} // namespace skeleton
} // namespace InterCommunication
} // namespace ara_api
} // namespace v1
#endif // !_InterCommunication_SKELETON_H_