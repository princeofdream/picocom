/***********************************************************************************************************
Generated by the KT-Adaptive-Generator!
The tool version : V2.2.1-e71a77
Copyright(C) 2021 Wuhan KOTEI Informatics Co.,Ltd. All rights reserved
***********************************************************************************************************/

#include "InterCommunication_proxy.hpp"
#include "ara/com/AddressTranslator.h"
#include "ara_runtime.hpp"
#include "json.hpp"
#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

using json = nlohmann::json;
namespace v1 {
namespace ara_api {
namespace InterCommunication {
namespace proxy {

ara::core::Result<
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType>>
InterCommunicationProxy::FindService(void) {
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType> ret;
    ara::com::ServiceIdentifierType service_identifier_type = v1::ara_api::
        InterCommunication::InterCommunicationIdentifier::ServiceIdentifier;
    std::map<std::string, ara::com::Someip_Address> address_list =
        ara::com::AddressTranslator::get()->GetAllAddressByInterface(
            std::string(service_identifier_type.toString()));
    if (address_list.size() > 0) {
        for (auto &_address : address_list) {
            InterCommunicationProxy::HandleType handle(
                _address.first, _address.second.getService(),
                _address.second.getInstance());
            if (ara::Runtime::getInstance()->find_service(
                    handle.get_service_id(), handle.get_instance_id(),
                    InterCommunicationIdentifier::
                        serviceContractVersionMajor)) {
                ret.push_back(handle);
            }
        }
    } else {
        return ara::core::Result<ara::com::ServiceHandleContainer<
            InterCommunicationProxy::HandleType>>::
            FromError(ara::com::ComErrc::kNetworkBindingFailure);
    }
    return ara::core::Result<ara::com::ServiceHandleContainer<
        InterCommunicationProxy::HandleType>>::FromValue(ret);
}

ara::core::Result<
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType>>
InterCommunicationProxy::FindService(ara::com::InstanceIdentifier instanceId) {
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType> ret;
    ara::com::Someip_Address someip_address;
    std::string id(instanceId.toString());
    if (ara::com::AddressTranslator::get()->translate(id, someip_address)) {
        InterCommunicationProxy::HandleType handle(
            id, someip_address.getService(), someip_address.getInstance());
        if (ara::Runtime::getInstance()->find_service(
                handle.get_service_id(), handle.get_instance_id(),
                InterCommunicationIdentifier::serviceContractVersionMajor)) {
            ret.push_back(handle);
        }
    } else {
        return ara::core::Result<ara::com::ServiceHandleContainer<
            InterCommunicationProxy::HandleType>>::
            FromError(ara::com::ComErrc::kNetworkBindingFailure);
    }
    return ara::core::Result<ara::com::ServiceHandleContainer<
        InterCommunicationProxy::HandleType>>::FromValue(ret);
}

ara::core::Result<
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType>>
InterCommunicationProxy::FindService(
    ara::core::InstanceSpecifier instanceSpec) {
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType> ret;
    ara::core::Result<ara::com::InstanceIdentifierContainer>
        identifier_container =
            ara::com::runtime::ResolveInstanceIDs(instanceSpec);
    if (identifier_container.HasValue()) {
        for (ara::com::InstanceIdentifier id : identifier_container.Value()) {
            ara::core::Result<ara::com::ServiceHandleContainer<
                InterCommunicationProxy::HandleType>>
                tmp = InterCommunicationProxy::FindService(id);
            if (tmp.HasValue()) {
                for (auto handle : tmp.Value()) {
                    ret.push_back(handle);
                }
            } else {
                return ara::core::Result<ara::com::ServiceHandleContainer<
                    InterCommunicationProxy::HandleType>>::
                    FromError(tmp.Error());
            }
        }
    } else {
        return ara::core::Result<ara::com::ServiceHandleContainer<
            InterCommunicationProxy::HandleType>>::
            FromError(identifier_container.Error());
    }
    return ara::core::Result<ara::com::ServiceHandleContainer<
        InterCommunicationProxy::HandleType>>::FromValue(ret);
}

ara::core::Result<
    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType>>
InterCommunicationProxy::StartFindService(ara::ServiceStatusCallback _cb) {
    if (!_cb) {
        // func callback is NULL
        return ara::core::Result<ara::com::ServiceHandleContainer<
            InterCommunicationProxy::HandleType>>::
            FromError(ara::com::ComErrc::kServiceNotAvailable);
    }

    ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType> ret;

    ara::com::ServiceIdentifierType service_identifier_type = v1::ara_api::
        InterCommunication::InterCommunicationIdentifier::ServiceIdentifier;
    std::map<std::string, ara::com::Someip_Address> address_list =
        ara::com::AddressTranslator::get()->GetAllAddressByInterface(
            std::string(service_identifier_type.toString()));
    if (address_list.size() > 0) {
        for (auto &_address : address_list) {
            soaSlogI("0x%08x", &_address);
            InterCommunicationProxy::HandleType handle(
                _address.first, _address.second.getService(),
                _address.second.getInstance());
            ara::Runtime::getInstance()->registerServiceStatusCallBack(
                handle.get_service_id(), handle.get_instance_id(),
                InterCommunicationIdentifier::serviceContractVersionMajor, _cb);
            ret.push_back(handle);
        }
        return ret;
    }
    // size of address_list is 0
    return ara::core::Result<
        ara::com::ServiceHandleContainer<InterCommunicationProxy::HandleType>>::
        FromError(ara::com::ComErrc::kServiceNotAvailable);
}

void InterCommunicationProxy::StopFindService(
    ara::com::FindServiceHandle handle) {
    // TODO:call runtime api
}

#ifdef CONFIG_ENABLE_PHM
long long getCurrentTimeMillis() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}
#endif // CONFIG_ENABLE_PHM

InterCommunicationProxy::InterCommunicationProxy(
    const InterCommunicationProxy::HandleType &handle)
    : _running(true), m_proxy_handle(handle),
      InterRequestRR(handle.GetInstanceId()),
      InterRequest(handle.GetInstanceId()), InterEvent(handle.GetInstanceId()),
      InterEventArr(handle.GetInstanceId()), InterField(handle.GetInstanceId()),
      InterFieldArr(handle.GetInstanceId())

{
#if CONFIG_FORCE_POLLING
    m_get_method_result_thread = std::thread(
        std::bind(&InterCommunicationProxy::GetMethodCallResult_Doing, this));
#endif // CONFIG_FORCE_POLLING
}

InterCommunicationProxy::HandleType InterCommunicationProxy::GetHandle() const {
    return m_proxy_handle;
}

const ara::com::InstanceIdentifier &
InterCommunicationProxy::HandleType::GetInstanceId() const {
    return instance_identifier;
}

namespace methods {

InterRequestRR::InterRequestRR(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier) {}

ara::core::Future<Array_InterComm>
InterRequestRR::operator()(Array_InterComm &Array_InterReq) {
    ara::core::Promise<Array_InterComm> _promise;
    ara::core::Future<Array_InterComm> _furure = _promise.get_future();
    ara::com::Someip_Address _address;
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        apf::Serializer _out;

        if (apf::someip::SerializableArguments<Array_InterComm>::Serializer(
                _out, Array_InterReq)) {
            ara::Message msg = ara::Message::createRequestMessage(true);
            msg.setService(_address.getService());
            msg.setInstance(_address.getInstance());
            msg.setMethod(INTERREQUESTRR_METHOD_ID);
            msg.setPayloadData((uint8_t *)_out.getBuffSnapShot().data(),
                               _out.getBuffSnapShot().size());
            ara::com::internal::SessionId _session_id;
#ifdef CONFIG_ENABLE_PHM
            long current_time = (long)getCurrentTimeMillis();
#endif // CONFIG_ENABLE_PHM
            ara::Runtime::getInstance()->send_msg(
                msg, std::bind(&methods::InterRequestRR::RecvResponseHandle,
                               this, std::placeholders::_1));
            _session_id = msg.getSession();
#ifdef CONFIG_ENABLE_PHM
            ara::Runtime::getInstance()->send_call_chain_use_phm(
                current_time, 0, std::to_string(msg.getMethod()),
                std::to_string(msg.getClientId()), 0, 1, 0);
#endif // CONFIG_ENABLE_PHM
            m_wait_return_map[_session_id] = std::move(_promise);
        }
    } else {
        _promise.SetError(ara::com::ComErrc::kNetworkBindingFailure);
    }
    return _furure;
}

InterRequestRR::~InterRequestRR() { m_wait_return_map.clear(); }
void InterRequestRR::RecvResponseHandle(ara::Message _msg) {
    ara::com::internal::SessionId session_id = _msg.getSession();
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTERREQUESTRR_METHOD_ID) {
        if (m_wait_return_map.find(session_id) != m_wait_return_map.end()) {
            apf::Deserializer _in(_msg.getBodyData(), _msg.getBodyLength());
            Array_InterComm Array_InterRespOut;
            if (apf::someip::SerializableArguments<
                    Array_InterComm>::Deserializer(_in, Array_InterRespOut)) {
                m_wait_return_map[session_id].set_value(Array_InterRespOut);
            } else {
                m_wait_return_map[session_id].SetError(
                    ara::com::ComErrc::kCommunicationStackError);
            }
            m_wait_return_map.erase(session_id);
        }
    }
}
InterRequest::InterRequest(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier) {}

void InterRequest::operator()(Array_InterComm &Array_InterReq) {
    ara::com::Someip_Address _address;
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        apf::Serializer _out;

        if (apf::someip::SerializableArguments<Array_InterComm>::Serializer(
                _out, Array_InterReq)) {
            ara::Message msg = ara::Message::createRequestMessage();

            msg.setService(_address.getService());
            msg.setInstance(_address.getInstance());
            msg.setMethod(INTERREQUEST_METHOD_ID);
            msg.setPayloadData((uint8_t *)_out.getBuffSnapShot().data(),
                               _out.getBuffSnapShot().size());
            ara::Runtime::getInstance()->send_msg(msg, nullptr);
        }
    }
}

} // namespace methods

namespace events {
InterEvent::InterEvent(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier), m_running(true) {}

#if CONFIG_FORCE_POLLING
void InterEvent::RecvEventHandle(ara::Message _msg) {
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTEREVENT_EVENT_ID) {
        std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
        if (m_lastNActiveSamples.size() < m_max_sample_count) {
            m_lastNActiveSamples.push_back(_msg);
        }
    }
}
#else  // CONFIG_FORCE_POLLING
void InterEvent::RecvEventHandle(ara::Message _msg) {
    unsigned int size = _msg.getBodyLength();
    unsigned char *data = _msg.getBodyData();
    std::ostringstream oss;
    for (size_t i = 0; i < size; ++i) {
        oss << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(data[i]) << " ";
    }
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTEREVENT_EVENT_ID) {
        int size = 0;
        {
            std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
            if (m_lastNActiveSamples.size() < m_max_sample_count) {
                m_lastNActiveSamples.push_back(_msg);
            }
            size = m_lastNActiveSamples.size();
        }
        if (size > 0 && m_receive_handle != nullptr) {
            m_receive_handle();
        }
    }
}
#endif // CONFIG_FORCE_POLLING

ara::core::Result<void> InterEvent::Subscribe(size_t maxSampleCount) {
    ara::com::Someip_Address _address;
    soaSlogI("InterEvent::%s", __func__);
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        m_call_back_id = ara::Runtime::getInstance()->subscribe(
            _address.getService(), _address.getInstance(), INTEREVENT_EVENT_ID,
            std::bind(&events::InterEvent::RecvEventHandle, this,
                      std::placeholders::_1),
            EVENTGROUP_INTERCOMMUNICATION,
            InterCommunicationIdentifier::serviceContractVersionMajor);
        m_max_sample_count = maxSampleCount;
        m_is_subscribed = true;
    }
    return ara::core::Result<void>();
}

void InterEvent::Unsubscribe() {
    soaSlogI("InterEvent::%s", __func__);
    if (m_is_subscribed) {
        ara::com::Someip_Address _address;
        if (ara::com::AddressTranslator::get()->translate(
                std::string(m_identifier.toString()), _address)) {
            ara::Runtime::getInstance()->unsubscribe(
                _address.getService(), _address.getInstance(),
                INTEREVENT_EVENT_ID, m_call_back_id,
                EVENTGROUP_INTERCOMMUNICATION,
                InterCommunicationIdentifier::serviceContractVersionMajor);
        }
        m_is_subscribed = false;
    }
}

ara::core::Result<void>
InterEvent::SetReceiveHandler(ara::com::EventReceiveHandler handler) {
    m_receive_handle = handler;
    return ara::core::Result<void>::FromValue();
}

void InterEvent::UnsetReceiveHandler() { m_receive_handle = nullptr; }

InterEventArr::InterEventArr(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier), m_running(true) {}

#if CONFIG_FORCE_POLLING
void InterEventArr::RecvEventHandle(ara::Message _msg) {
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTEREVENTARR_EVENT_ID) {
        std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
        if (m_lastNActiveSamples.size() < m_max_sample_count) {
            m_lastNActiveSamples.push_back(_msg);
        }
    }
}
#else  // CONFIG_FORCE_POLLING
void InterEventArr::RecvEventHandle(ara::Message _msg) {
    unsigned int size = _msg.getBodyLength();
    unsigned char *data = _msg.getBodyData();
    std::ostringstream oss;
    for (size_t i = 0; i < size; ++i) {
        oss << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(data[i]) << " ";
    }
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTEREVENTARR_EVENT_ID) {
        int size = 0;
        {
            std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
            if (m_lastNActiveSamples.size() < m_max_sample_count) {
                m_lastNActiveSamples.push_back(_msg);
            }
            size = m_lastNActiveSamples.size();
        }
        if (size > 0 && m_receive_handle != nullptr) {
            m_receive_handle();
        }
    }
}
#endif // CONFIG_FORCE_POLLING

ara::core::Result<void> InterEventArr::Subscribe(size_t maxSampleCount) {
    ara::com::Someip_Address _address;
    soaSlogI("InterEventArr::%s", __func__);
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        m_call_back_id = ara::Runtime::getInstance()->subscribe(
            _address.getService(), _address.getInstance(),
            INTEREVENTARR_EVENT_ID,
            std::bind(&events::InterEventArr::RecvEventHandle, this,
                      std::placeholders::_1),
            EVENTGROUP_INTERCOMMUNICATION,
            InterCommunicationIdentifier::serviceContractVersionMajor);
        m_max_sample_count = maxSampleCount;
        m_is_subscribed = true;
    }
    return ara::core::Result<void>();
}

void InterEventArr::Unsubscribe() {
    soaSlogI("InterEventArr::%s", __func__);
    if (m_is_subscribed) {
        ara::com::Someip_Address _address;
        if (ara::com::AddressTranslator::get()->translate(
                std::string(m_identifier.toString()), _address)) {
            ara::Runtime::getInstance()->unsubscribe(
                _address.getService(), _address.getInstance(),
                INTEREVENTARR_EVENT_ID, m_call_back_id,
                EVENTGROUP_INTERCOMMUNICATION,
                InterCommunicationIdentifier::serviceContractVersionMajor);
        }
        m_is_subscribed = false;
    }
}

ara::core::Result<void>
InterEventArr::SetReceiveHandler(ara::com::EventReceiveHandler handler) {
    m_receive_handle = handler;
    return ara::core::Result<void>::FromValue();
}

void InterEventArr::UnsetReceiveHandler() { m_receive_handle = nullptr; }

} // namespace events

namespace fields {

InterField::InterField(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier), m_running(true) {}

InterField::~InterField() {
    m_running = false;
    m_wait_return_map.clear();

    Unsubscribe();
    m_call_back_thread.join();
}

#if CONFIG_FORCE_POLLING
void InterField::RecvEventHandle(ara::Message _msg) {
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTERFIELD_UPDATE_ID) {
        std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
        if (m_lastNActiveSamples.size() < m_max_sample_count) {
            soaSlogD("RecvEventHandle push back");
            m_lastNActiveSamples.push_back(_msg);
        }
    }
}
#else  // CONFIG_FORCE_POLLING
void InterField::RecvEventHandle(ara::Message _msg) {
    unsigned int size = _msg.getBodyLength();
    unsigned char *data = _msg.getBodyData();
    std::ostringstream oss;
    for (size_t i = 0; i < size; ++i) {
        oss << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(data[i]) << " ";
    }
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTERFIELD_UPDATE_ID) {
        int size = 0;
        {
            std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
            if (m_lastNActiveSamples.size() < m_max_sample_count) {
                m_lastNActiveSamples.push_back(_msg);
            }
            size = m_lastNActiveSamples.size();
        }
        if (size > 0 && m_receive_handle != nullptr) {
            m_receive_handle();
        }
    }
}
#endif // CONFIG_FORCE_POLLING

ara::core::Result<void> InterField::Subscribe(size_t maxSampleCount) {
    ara::com::Someip_Address _address;
    soaSlogI("InterField::%s", __func__);
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        m_call_back_id = ara::Runtime::getInstance()->subscribe(
            _address.getService(), _address.getInstance(), INTERFIELD_UPDATE_ID,
            std::bind(&fields::InterField::RecvEventHandle, this,
                      std::placeholders::_1),
            EVENTGROUP_INTERCOMMUNICATION,
            InterCommunicationIdentifier::serviceContractVersionMajor);
        m_max_sample_count = maxSampleCount;
        m_is_subscribed = true;
    }
    return ara::core::Result<void>();
}

void InterField::Unsubscribe() {
    soaSlogI("InterField::%s", __func__);
    if (m_is_subscribed) {
        ara::com::Someip_Address _address;
        if (ara::com::AddressTranslator::get()->translate(
                std::string(m_identifier.toString()), _address)) {
            ara::Runtime::getInstance()->unsubscribe(
                _address.getService(), _address.getInstance(),
                INTERFIELD_UPDATE_ID, m_call_back_id);
        }
        m_is_subscribed = false;
    }
}

ara::core::Result<void>
InterField::SetReceiveHandler(ara::com::EventReceiveHandler handler) {
    m_receive_handle = handler;
    return ara::core::Result<void>::FromValue();
}

void InterField::UnsetReceiveHandler() { m_receive_handle = nullptr; }

void InterField::RecvResponseHandle(ara::Message _msg) {
    ara::com::internal::SessionId session_id = _msg.getSession();
    ara::com::internal::MethodId method_id = _msg.getMethod();
    {
        if (m_wait_return_map.find(session_id) != m_wait_return_map.end()) {
            apf::Deserializer _in(_msg.getBodyData(), _msg.getBodyLength());

            Struct_InterField value;
            if (apf::someip::SerializableArguments<
                    Struct_InterField>::Deserializer(_in, value)) {
                m_wait_return_map[session_id].set_value(value);
            } else {
                m_wait_return_map[session_id].SetError(
                    ara::com::ComErrc::kCommunicationStackError);
            }

            m_wait_return_map.erase(session_id);
        }
    }
}

ara::core::Future<InterField::FieldType> InterField::Get() {
    ara::core::Promise<FieldType> _promise;
    ara::core::Future<FieldType> _future = _promise.get_future();
    ara::com::Someip_Address _address;
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {

        ara::com::internal::SessionId _session_id;
        ara::Message msg = ara::Message::createRequestMessage();

        msg.setService(_address.getService());
        msg.setInstance(_address.getInstance());
        msg.setMethod(INTERFIELD_GETTER_ID);
        ara::Runtime::getInstance()->send_msg(
            msg, std::bind(&fields::InterField::RecvResponseHandle, this,
                           std::placeholders::_1));
        _session_id = msg.getSession();
        m_wait_return_map.insert(
            std::make_pair(_session_id, std::move(_promise)));
    } else {
        _promise.SetError(ara::com::ComErrc::kNetworkBindingFailure);
    }
    return _future;
}

ara::core::Future<InterField::FieldType> InterField::Set(FieldType &value) {
    ara::core::Promise<FieldType> _promise;
    ara::core::Future<FieldType> _future = _promise.get_future();
    ara::com::Someip_Address _address;
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        apf::Serializer _out;

        if (apf::someip::SerializableArguments<Struct_InterField>::Serializer(
                _out, value)) {
            ara::com::internal::SessionId _session_id;
            ara::Message msg = ara::Message::createRequestMessage();

            msg.setService(_address.getService());
            msg.setInstance(_address.getInstance());
            msg.setMethod(INTERFIELD_SETTER_ID);
            msg.setPayloadData((uint8_t *)_out.getBuffSnapShot().data(),
                               _out.getBuffSnapShot().size());
            ara::Runtime::getInstance()->send_msg(
                msg, std::bind(&fields::InterField::RecvResponseHandle, this,
                               std::placeholders::_1));
            _session_id = msg.getSession();

            m_wait_return_map.insert(
                std::make_pair(_session_id, std::move(_promise)));
        }
    } else {
        _promise.SetError(ara::com::ComErrc::kNetworkBindingFailure);
    }
    return _future;
}

InterFieldArr::InterFieldArr(ara::com::InstanceIdentifier _identifier)
    : m_identifier(_identifier), m_running(true) {}

InterFieldArr::~InterFieldArr() {
    m_running = false;
    Unsubscribe();
    m_call_back_thread.join();
}

#if CONFIG_FORCE_POLLING
void InterFieldArr::RecvEventHandle(ara::Message _msg) {
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTERFIELDARR_UPDATE_ID) {
        std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
        if (m_lastNActiveSamples.size() < m_max_sample_count) {
            soaSlogD("RecvEventHandle push back");
            m_lastNActiveSamples.push_back(_msg);
        }
    }
}
#else  // CONFIG_FORCE_POLLING
void InterFieldArr::RecvEventHandle(ara::Message _msg) {
    unsigned int size = _msg.getBodyLength();
    unsigned char *data = _msg.getBodyData();
    std::ostringstream oss;
    for (size_t i = 0; i < size; ++i) {
        oss << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(data[i]) << " ";
    }
    ara::com::internal::MethodId method_id = _msg.getMethod();
    if (method_id == INTERFIELDARR_UPDATE_ID) {
        int size = 0;
        {
            std::lock_guard<std::mutex> data_lock(m_lastNActiveSamples_mutex);
            if (m_lastNActiveSamples.size() < m_max_sample_count) {
                m_lastNActiveSamples.push_back(_msg);
            }
            size = m_lastNActiveSamples.size();
        }
        if (size > 0 && m_receive_handle != nullptr) {
            m_receive_handle();
        }
    }
}
#endif // CONFIG_FORCE_POLLING

ara::core::Result<void> InterFieldArr::Subscribe(size_t maxSampleCount) {
    ara::com::Someip_Address _address;
    soaSlogI("InterFieldArr::%s", __func__);
    if (ara::com::AddressTranslator::get()->translate(
            std::string(m_identifier.toString()), _address)) {
        m_call_back_id = ara::Runtime::getInstance()->subscribe(
            _address.getService(), _address.getInstance(),
            INTERFIELDARR_UPDATE_ID,
            std::bind(&fields::InterFieldArr::RecvEventHandle, this,
                      std::placeholders::_1),
            EVENTGROUP_INTERCOMMUNICATION,
            InterCommunicationIdentifier::serviceContractVersionMajor);
        m_max_sample_count = maxSampleCount;
        m_is_subscribed = true;
    }
    return ara::core::Result<void>();
}

void InterFieldArr::Unsubscribe() {
    soaSlogI("InterFieldArr::%s", __func__);
    if (m_is_subscribed) {
        ara::com::Someip_Address _address;
        if (ara::com::AddressTranslator::get()->translate(
                std::string(m_identifier.toString()), _address)) {
            ara::Runtime::getInstance()->unsubscribe(
                _address.getService(), _address.getInstance(),
                INTERFIELDARR_UPDATE_ID, m_call_back_id);
        }
        m_is_subscribed = false;
    }
}

ara::core::Result<void>
InterFieldArr::SetReceiveHandler(ara::com::EventReceiveHandler handler) {
    m_receive_handle = handler;
    return ara::core::Result<void>::FromValue();
}

void InterFieldArr::UnsetReceiveHandler() { m_receive_handle = nullptr; }

} // namespace fields

InterCommunicationProxy::HandleType::HandleType(
    std::string instance_name, ara::com::internal::ServiceId _service_id,
    ara::com::internal::InstanceId _instance_id)
    : instance_identifier(instance_name), service_id(_service_id),
      instance_id(_instance_id) {
    ;
}

bool InterCommunicationProxy::HandleType::operator==(
    const HandleType &other) const {
    return (service_id == other.service_id && instance_id == other.instance_id);
}

bool InterCommunicationProxy::HandleType::operator<(
    const HandleType &other) const {
    if (service_id < other.service_id) {
        return true;
    } else if (service_id == other.service_id &&
               instance_id < other.instance_id) {
        return true;
    }
    return false;
}

InterCommunicationProxy::HandleType::HandleType(const HandleType &other)
    : instance_identifier(other.instance_identifier) {
    service_id = other.service_id;
    instance_id = other.instance_id;
}

InterCommunicationProxy::HandleType &
InterCommunicationProxy::HandleType::operator=(const HandleType &other) {
    service_id = other.service_id;
    instance_id = other.instance_id;
    instance_identifier = other.instance_identifier;
    return *this;
}

InterCommunicationProxy::HandleType::HandleType(HandleType &&other)
    : instance_identifier(other.instance_identifier) {
    service_id = other.service_id;
    instance_id = other.instance_id;
}

InterCommunicationProxy::HandleType &
InterCommunicationProxy::HandleType::operator=(HandleType &&other) {
    *this = std::move(other);
    return *this;
}

ara::com::internal::ServiceId
InterCommunicationProxy::HandleType::get_service_id() {
    return service_id;
}

ara::com::internal::InstanceId
InterCommunicationProxy::HandleType::get_instance_id() {
    return instance_id;
}

ara::core::Result<InterCommunicationProxy>
InterCommunicationProxy::Create(const HandleType &handle) noexcept {
    try {
        InterCommunicationProxy _proxy(handle);
        return ara::core::Result<InterCommunicationProxy>::FromValue(
            std::move(_proxy));
    } catch (...) {
        return ara::core::Result<InterCommunicationProxy>::FromError(
            ara::com::ComErrc::kGrantEnforcementError);
    }
}

InterCommunicationProxy::InterCommunicationProxy(
    InterCommunicationProxy &&_Right)
    : m_proxy_handle(_Right.GetHandle()),
      InterRequestRR(_Right.GetHandle().GetInstanceId()),
      InterRequest(_Right.GetHandle().GetInstanceId()),
      InterEvent(_Right.GetHandle().GetInstanceId()),
      InterEventArr(_Right.GetHandle().GetInstanceId()),
      InterField(_Right.GetHandle().GetInstanceId()),
      InterFieldArr(_Right.GetHandle().GetInstanceId()) {
    *this = std::move(_Right);
#if CONFIG_FORCE_POLLING
    m_get_method_result_thread = std::thread(
        std::bind(&InterCommunicationProxy::GetMethodCallResult_Doing, this));
#endif // CONFIG_FORCE_POLLING
}

InterCommunicationProxy &
InterCommunicationProxy::operator=(InterCommunicationProxy &&_Right) {
    *this = std::move(_Right);
    return *this;
}

void InterCommunicationProxy::Init() {
    ara::Runtime::getInstance()->insert_request_service_info(
        0xF001, 0x0001,
        InterCommunicationIdentifier::serviceContractVersionMajor);
}

void InterCommunicationProxy::Deinit() {
    // TODO deinit resources
}

InterCommunicationProxy::~InterCommunicationProxy() {
    _running = false;
#if CONFIG_FORCE_POLLING
    m_get_method_result_thread.join();
#endif // CONFIG_FORCE_POLLING
}

#if CONFIG_FORCE_POLLING
void InterCommunicationProxy::GetMethodCallResult_Doing() {
    while (_running) {

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if (InterEvent.m_lastNActiveSamples.size() > 0 &&
            InterEvent.m_receive_handle != nullptr) {
            InterEvent.m_receive_handle();
        }

        if (InterEventArr.m_lastNActiveSamples.size() > 0 &&
            InterEventArr.m_receive_handle != nullptr) {
            InterEventArr.m_receive_handle();
        }

        if (InterField.m_lastNActiveSamples.size() > 0 &&
            InterField.m_receive_handle != nullptr) {
            InterField.m_receive_handle();
        }

        if (InterFieldArr.m_lastNActiveSamples.size() > 0 &&
            InterFieldArr.m_receive_handle != nullptr) {
            InterFieldArr.m_receive_handle();
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}
#endif // CONFIG_FORCE_POLLING

void InterCommunicationProxy::setClientID(const char *jsonFilePath,
                                          const char *serviceName) {
    bool isReadData = false;
    std::ifstream f(jsonFilePath);
    json data = json::parse(f);
    try {
        // parse json
        for (auto it : data) {
            if (it["pkgName"].get<std::string>() == serviceName) {
                m_clientId = it["clientId"].get<std::string>().c_str();
                isReadData = true;
                break;
            }
        }
    } catch (const std::exception &e) {
        // TODO
        soaSlogW("JSON File error!");
    }
    if (!isReadData) {
        // TODO
        soaSlogW("read client from json file failed!");
    }
}

void InterCommunicationProxy::getClientID(const char *&client_id) {
    client_id = m_clientId;
}

} // namespace proxy
} // namespace InterCommunication
} // namespace ara_api
} // namespace v1