/***********************************************************************************************************
Generated by the KT-Adaptive-Generator!
The tool version : V2.2.1-e71a77
Copyright(C) 2021 Wuhan KOTEI Informatics Co.,Ltd. All rights reserved
***********************************************************************************************************/

#include "InterCommunication_common.hpp"
#include "ara/com/AddressTranslator.h"

#include "ara_runtime.hpp"
constexpr ara::com::ServiceIdentifierType v1::ara_api::InterCommunication::
    InterCommunicationIdentifier::ServiceIdentifier;
constexpr ara::com::ServiceVersionType v1::ara_api::InterCommunication::
    InterCommunicationIdentifier::ServiceVersion;

v1::ara_api::InterCommunication::InterCommunicationInit InterCommunication_init;
v1::ara_api::InterCommunication::InterCommunicationInit::
    InterCommunicationInit() {
    soaSlogI("SOA Lib [ InterCommunication ] version: %s",
             v1::ara_api::InterCommunication::InterCommunicationIdentifier::
                 ServiceVersion.toString()
                     .data());

    apf::someip::Configuration::GetInstance().setAlignment(
        apf::someip::Alignment::kAlign8Bit);

    ara::com::AddressTranslator::get()->insert(
        "local:ara_api.InterCommunication:instance_name", 0xF001, 0x0001,
        InterCommunicationIdentifier::serviceContractVersionMajor, 0);
}

namespace v1 {
namespace ara_api {
namespace InterCommunication {

std::uint8_t InterCommunicationIdentifier::serviceContractVersionMajor = 1;
std::uint32_t InterCommunicationIdentifier::serviceContractVersionMinor = 1;

uint32_t InterCommunicationIdentifier::CreateProxyID() {
    static uint32_t id = 0;
    id++;
    return id;
}

void Struct_InterFieldData::setUint8_DataID(const uint8_t &_Uint8_DataID) {
    m_Uint8_DataID = _Uint8_DataID;
}
uint8_t Struct_InterFieldData::getUint8_DataID() const {
    return m_Uint8_DataID;
}
void Struct_InterFieldData::setString_DataMsg(
    const ara::core::String &_String_DataMsg) {
    m_String_DataMsg = _String_DataMsg;
}

uint32_t Struct_InterFieldData::getSize() {
    return static_cast<uint32_t>(sizeof(uint8_t) + 0);
}

apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                              Struct_InterFieldData &_data) {
    _inputBuffer >> _data.m_length;
    if (!_data.isBufferEnough(_inputBuffer)) {
        return _inputBuffer;
    }
    _inputBuffer >> _data.m_Uint8_DataID;
    _inputBuffer >> _data.m_String_DataMsg;
    return _inputBuffer;
}

apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                            Struct_InterFieldData &_data) {
    size_t offset = _outputbuffer.getSize();
    _outputbuffer << _data.m_length;
    _outputbuffer << _data.m_Uint8_DataID;
    _outputbuffer << _data.m_String_DataMsg;
    apf::someip::Common::GetInstance().setLengthByOffset(_outputbuffer, offset,
                                                         _data.m_length);
    return _outputbuffer;
}

void Struct_InterFieldStArr::setUint8_DataID(const uint8_t &_Uint8_DataID) {
    m_Uint8_DataID = _Uint8_DataID;
}
uint8_t Struct_InterFieldStArr::getUint8_DataID() const {
    return m_Uint8_DataID;
}
void Struct_InterFieldStArr::setArray_InterComm(
    const Array_InterComm &_Array_InterComm) {
    m_Array_InterComm = _Array_InterComm;
}
Array_InterComm Struct_InterFieldStArr::getArray_InterComm() const {
    return m_Array_InterComm;
}
void Struct_InterFieldStArr::setString_DataMsg(
    const ara::core::String &_String_DataMsg) {
    m_String_DataMsg = _String_DataMsg;
}

uint32_t Struct_InterFieldStArr::getSize() {
    return static_cast<uint32_t>(sizeof(uint8_t) + 0 + 0);
}

apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                              Struct_InterFieldStArr &_data) {
    _inputBuffer >> _data.m_length;
    if (!_data.isBufferEnough(_inputBuffer)) {
        return _inputBuffer;
    }
    _inputBuffer >> _data.m_Uint8_DataID;
    _inputBuffer >> _data.m_Array_InterComm;
    _inputBuffer >> _data.m_String_DataMsg;
    return _inputBuffer;
}

apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                            Struct_InterFieldStArr &_data) {
    size_t offset = _outputbuffer.getSize();
    _outputbuffer << _data.m_length;
    _outputbuffer << _data.m_Uint8_DataID;
    _outputbuffer << _data.m_Array_InterComm;
    _outputbuffer << _data.m_String_DataMsg;
    apf::someip::Common::GetInstance().setLengthByOffset(_outputbuffer, offset,
                                                         _data.m_length);
    return _outputbuffer;
}

void Struct_InterField::setUint8_InterFieldID(
    const uint8_t &_Uint8_InterFieldID) {
    m_Uint8_InterFieldID = _Uint8_InterFieldID;
}
uint8_t Struct_InterField::getUint8_InterFieldID() const {
    return m_Uint8_InterFieldID;
}
void Struct_InterField::setStruct_InterFieldData(
    const Struct_InterFieldData &_Struct_InterFieldData) {
    m_Struct_InterFieldData = _Struct_InterFieldData;
}
Struct_InterFieldData Struct_InterField::getStruct_InterFieldData() const {
    return m_Struct_InterFieldData;
}
uint32_t Struct_InterField::getSize() {
    return static_cast<uint32_t>(sizeof(uint8_t) +
                                 m_Struct_InterFieldData.getSize());
}

apf::Deserializer &operator>>(apf::Deserializer &_inputBuffer,
                              Struct_InterField &_data) {
    _inputBuffer >> _data.m_length;
    if (!_data.isBufferEnough(_inputBuffer)) {
        return _inputBuffer;
    }
    _inputBuffer >> _data.m_Uint8_InterFieldID;
    _inputBuffer >> _data.m_Struct_InterFieldData;
    return _inputBuffer;
}

apf::Serializer &operator<<(apf::Serializer &_outputbuffer,
                            Struct_InterField &_data) {
    size_t offset = _outputbuffer.getSize();
    _outputbuffer << _data.m_length;
    _outputbuffer << _data.m_Uint8_InterFieldID;
    _outputbuffer << _data.m_Struct_InterFieldData;
    apf::someip::Common::GetInstance().setLengthByOffset(_outputbuffer, offset,
                                                         _data.m_length);
    return _outputbuffer;
}

// \brief Construct a new ConnMgrErrcException from an ErrorCode.
InterCommunicationException::InterCommunicationException(
    ara::core::ErrorCode err) noexcept
    : Exception(err) {}

char const *InterCommunicationException::what() const noexcept {
    return m_error_code.Message();
}

ara::core::ErrorCode const &
InterCommunicationException::Error() const noexcept {
    return m_error_code;
}

char const *InterCommunicationErrorDomain::Name() const noexcept {
    return "InterCommunication";
}

char const *InterCommunicationErrorDomain::Message(
    ErrorDomain::CodeType errorCode) const noexcept {
    static const std::pair<InterCommunicationErrc, const char *>
        err_and_message[] = {
            {InterCommunicationErrc::error_code1, "error_code1"},
        };

    return MatchAndPickupItem_withDefault(
        err_and_message,
        _item.first == static_cast<InterCommunicationErrc>(errorCode),
        _item.second, "");
}

void InterCommunicationErrorDomain::ThrowAsException(
    ara::core::ErrorCode const &errorCode) const noexcept(false) {
    throw(Exception(errorCode));
}

constexpr ara::core::ErrorDomain const &
GetInterCommunicationErrcDomain() noexcept {
    return s_InterCommunication_error_domain;
}

ara::core::ErrorCode MakeErrorCode(InterCommunicationErrc code,
                                   ara::core::ErrorDomain::SupportDataType data,
                                   char const *message) noexcept {
    return ara::core::ErrorCode((ara::core::ErrorDomain::CodeType)code,
                                GetInterCommunicationErrcDomain(), data,
                                message);
}

} // namespace InterCommunication
} // namespace ara_api
} // namespace v1